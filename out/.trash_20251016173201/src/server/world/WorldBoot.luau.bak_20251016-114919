--!strict
print("WB_SYNC_PING", os.time())
local ServerScriptService = game:GetService("ServerScriptService")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Modules = ServerScriptService:FindFirstChild("Modules")
local BuildGuard
if Modules and Modules:FindFirstChild("BuildGuard") then
    local ok, mod = pcall(function()
        return require(Modules.BuildGuard)
    end)
    if ok then
        BuildGuard = mod
    else
        warn("[WorldBoot] BuildGuard failed; continuing")
    end
else
    warn("[WorldBoot] BuildGuard not found; continuing")
end
if BuildGuard and typeof(BuildGuard.Run) == "function" then
    pcall(function()
        BuildGuard.Run()
    end)
end
local Spawn = require(script.Parent:WaitForChild("Spawn"))
local Garage
do
    local gFolder = script.Parent:FindFirstChild("Garage")
    if not gFolder then
        warn("[WorldBoot] Garage folder missing under ServerScriptService/World; skipping mount")
    else
        local ok, modOrErr = pcall(function()
            return require(gFolder:WaitForChild("Component", 5))
        end)
        if ok then
            Garage = modOrErr
        else
            warn("[WorldBoot] require Garage.Component failed:", modOrErr)
        end
    end
end

local shared = ReplicatedStorage:WaitForChild("shared")
local GameConstants = require(shared:WaitForChild("config"):WaitForChild("GameConstants"))

local function ensureDoorPivot(garage: Model)
	local existing = garage:FindFirstChild("DoorPivot") :: BasePart?
	if existing then
		if garage.PrimaryPart == nil then
			garage.PrimaryPart = existing
		end
		return existing
	end
	local pivot = Instance.new("Part")
	pivot.Name = "DoorPivot"
	pivot.Anchored = true
	pivot.CanCollide = false
	pivot.Transparency = 1
	pivot.Size = Vector3.new(0.2, 0.2, 0.2)
	pivot.Parent = garage
	local posAttr = garage:GetAttribute("DoorCenter")
	if typeof(posAttr) == "Vector3" then
		pivot.CFrame = CFrame.new(posAttr)
	elseif garage.PrimaryPart then
		pivot.CFrame = garage.PrimaryPart.CFrame
	else
		pivot.CFrame = garage:GetPivot()
	end
	garage.PrimaryPart = pivot
	return pivot
end

local function ensureSpawnLocation(cf: CFrame)
	local spawn = workspace:FindFirstChild("RC_Spawn") :: SpawnLocation?
	if not spawn then
		spawn = Instance.new("SpawnLocation")
		spawn.Name = "RC_Spawn"
		spawn.Parent = workspace
	end
	spawn.CFrame = cf
	spawn.Anchored = true
	spawn.Neutral = true
	spawn.Enabled = true
	spawn.Duration = 0
	spawn.Size = Vector3.new(6, 1, 6)
	for _, inst in ipairs(workspace:GetChildren()) do
		if inst:IsA("SpawnLocation") and inst ~= spawn then
			inst:Destroy()
		end
	end
	return spawn
end

local WorldBoot = {}

function WorldBoot.run()
  if BuildGuard and typeof(BuildGuard.once) == "function" then
    local ok, result = pcall(function()
      return BuildGuard.once("WorldBoot")
    end)
    if ok and result == false then
      warn("[WorldBoot] already ran; skipping")
      return
    end
  end
  -- spawn
  local okSpawn, errSpawn = pcall(function()
	  Spawn.ensure()
	  ensureSpawnLocation(CFrame.new(0, 3.5, -12))
  end)
  if not okSpawn then
    warn("[WorldBoot] Spawn.ensure() failed:", errSpawn)
  elseif RunService:IsStudio() then
    print("[WorldBoot] Spawn ensured")
  end

  -- verify artifacts
  local base = workspace:FindFirstChild("RC_Baseplate")
  local pad  = workspace:FindFirstChild("RC_Spawn")
  print("[WorldBoot] Spawn ready  base@", base and (base :: BasePart).Position, " pad@", pad and (pad :: BasePart).Position)
  print(("[WorldBoot] ticks movement=%.2f mining=%.2f"):format(GameConstants.MOVEMENT_TICK, GameConstants.MINING_TICK))
  print(("[WorldBoot] economy gearbits=%d-%d ion=%d-%d rare=%d-%d"):format(
    GameConstants.GEARBITS_PER_TICK.min,
    GameConstants.GEARBITS_PER_TICK.max,
    GameConstants.IONSHARDS_PER_TICK.min,
    GameConstants.IONSHARDS_PER_TICK.max,
    GameConstants.RAREMETALS_PER_TICK.min,
    GameConstants.RAREMETALS_PER_TICK.max
  ))

  -- garage
	local ownerPlayer = Players:GetPlayers()[1]
	local ownerUserId = ownerPlayer and ownerPlayer.UserId or nil
	local okGarage, unmountOrErr = pcall(function()
	-- If a garage already exists (PlotManager mounted it), skip mounting here
	local existing = workspace:FindFirstChild("GD_Garage") or (function()
		for _,m in ipairs(workspace:GetChildren()) do
			if m:IsA("Model") and m.Name:match("^GD_Garage") then return m end
		end
		return nil
	end)()
	if existing then
		if ownerUserId ~= nil and existing:GetAttribute("OwnerUserId") ~= ownerUserId then
			existing:SetAttribute("OwnerUserId", ownerUserId)
		end
		if not CollectionService:HasTag(existing, "GD_Garage") then
			CollectionService:AddTag(existing, "GD_Garage")
		end
		ensureDoorPivot(existing)
		print("[WorldBoot] garage already present; skipping mount (PlotManager likely handled it)")
	else
		-- Auto-place the garage relative to RC_Spawn so it‚Äôs visible right away
		local DIST = 40         -- ~‚Äú20 steps‚Äù; adjust 30..60 to taste
		local s = workspace:FindFirstChild("RC_Spawn") :: SpawnLocation?
		local origin, facing
		if s then
			local spawnPos = s.CFrame.Position
			local fwd      = s.CFrame.LookVector.Unit
			origin = Vector3.new(spawnPos.X, 0, spawnPos.Z) + fwd * DIST
			-- Make the garage face the player: outward = (spawn - origin)
			local look = (spawnPos - origin)
			if look.Magnitude < 1e-3 then
				facing = Vector3.new(0, 0, 1) -- fallback
			else
				local rawFacing = look.Unit
				-- Clamp to XZ plane so downstream geometry never inherits Y-tilt
				facing = Vector3.new(rawFacing.X, 0, rawFacing.Z).Unit
			end
			print(("[WorldBoot] placing garage: origin=%s facingDir=%s spawn=%s dist=%.1f")
				:format(tostring(origin), tostring(facing), tostring(spawnPos), DIST))
		else
			-- Fallback to previous fixed location if RC_Spawn not found
			origin = Vector3.new(24,0,12)
			facing = Vector3.new(0,0,1)
			warn("[WorldBoot] RC_Spawn not found; using fallback garage origin")
		end

		local _unmount = Garage.Mount({
			origin = origin,
			width  = 16.0,
			height = 14.0,
			depth  = 34.0,
			facing = facing,
			ownerUserId = ownerUserId,
		})
		-- Diagnostics: verify garage content presence
		task.defer(function()
			local gd = workspace:FindFirstChild("GD_Garage")
			if gd and gd:IsA("Model") then
				local parts, models = 0, 0
				for _,c in ipairs(gd:GetDescendants()) do
					if c:IsA("BasePart") then parts += 1 end
					if c:IsA("Model") then models += 1 end
				end
			print(string.format("[WorldBoot] GD_Garage online (parts=%d, models=%d)", parts, models))
			local door = gd:FindFirstChild("DoorPivot", true)
			if not door then warn("[WorldBoot] DoorPivot missing in GD_Garage (interior may be incomplete)") end
				do
					local CollectionService = game:GetService("CollectionService")
					local g = workspace:FindFirstChild("GD_Garage")
					if g then
						local cnt = 0
						for _, d in ipairs(g:GetDescendants()) do
							if d:IsA("BasePart") and (d.Size.Y <= GameConstants.THIN_TILE_Y_MAX and d.Position.Y <= 2.0) then
								if CollectionService:HasTag(d, "ResourceNode") then cnt += 1 end
							end
						end
						if cnt > 0 then
							warn(string.format("[WorldBoot] WARNING: %d thin garage parts tagged as ResourceNode", cnt))
						end
					end
				end
			if GameConstants.DEBUG then
				local PadAudit = require(game:GetService("ServerScriptService"):WaitForChild("Modules"):WaitForChild("PadAudit"))
				PadAudit.AuditOnce()
			end
	else
		warn("[WorldBoot] GD_Garage model not found after mount")
	end
end)
		-- TARGETED FIX: remove mispositioned GD_Lockers (source of "paver" tiles)
		task.defer(function()
			local gd = workspace:FindFirstChild("GD_Garage")
			if not gd or not gd:IsA("Model") then return end
			-- Opt-out switch: set World:SetAttribute("KEEP_LOCKERS", true) to keep them
			local worldFolder = script.Parent
			if worldFolder and worldFolder:GetAttribute("KEEP_LOCKERS") == true then return end
			local lockers = gd:FindFirstChild("GD_Lockers")
			if lockers and lockers:IsA("Model") then
				lockers:Destroy()
				if GameConstants.DEBUG then
					print("[WorldBoot] Removed GD_Lockers (temporary fix for ground tiles)")
				end
			end
		end)
  if not okGarage then
    warn("[WorldBoot] Garage.Mount failed:", unmountOrErr)
  end

  -- World presence check (TerrainLoader creates workspace/WorldZones)
  do
    local wz = workspace:FindFirstChild("WorldZones")
    if not wz then
      wz = workspace:WaitForChild("WorldZones", 5)
    end
    if not wz then
      warn("[WorldBoot] WorldZones not found after wait; TerrainLoader should create plaza/anchors/paths")
      return
    else
      local anchorsFolder = wz:FindFirstChild("Anchors")
      local pathsFolder = wz:FindFirstChild("Paths")
      local groundFolder = wz:FindFirstChild("Ground")
      local anchorsCount = 0
      if anchorsFolder then
        for _,_ in pairs(anchorsFolder:GetChildren()) do anchorsCount += 1 end
      end
      if RunService:IsStudio() then
        print(string.format("[WorldBoot] WorldZones OK (anchors=%d, paths=%d, ground=%s)",
          anchorsCount,
          pathsFolder and #pathsFolder:GetChildren() or 0,
          groundFolder and groundFolder:FindFirstChild("T0_Plaza") and "plaza" or "none"))
      end
    end
  end

  if GameConstants.DEBUG then
    print(("üåç WorldBoot ACTIVE %d"):format(os.time()))
  end
end

return WorldBoot
